package cs2030s.fp;

import java.util.List;
import java.util.NoSuchElementException;

/**
 * This class represents an infinite list of elements of type T.
 * The list is composed of a head element and a tail that is itself an InfiniteList.
 * @param <T> the type of elements in the list
 */
public class InfiniteList<T> {

  /**
   * The head element of the list, wrapped in a Lazy object.
   */
  private final Lazy<Maybe<T>> head;

  /**
   * The tail of the list, which is itself an InfiniteList, wrapped in a Lazy object.
   */
  private final Lazy<InfiniteList<T>> tail;

  /**
   * A sentinel value used to represent the end of the list.
   */
  private static final InfiniteList<?> SENTINEL = new Sentinel();

  /**
   * A private static final class that extends InfiniteList representing the end of the list.
   */
  private static final class Sentinel extends InfiniteList<Object> {

    /**
     * Returns a string representation of this Sentinel object.
     * @return a string representation of this Sentinel object.
     */
    @Override
    public String toString() {
      return "-";
    }


    /**
     * Returns true as it is a sentinel if method is triggered.
     * @return true if this object is a sentinel
     */
    @Override
    public boolean isSentinel() {
      return true;
    }

    /**
     * Applies the given transformer to each element of this list and returns
     * an infinite list of the results (always sentinel in this case).
     * @param <R> the type of the elements in the output list
     * @param mapper a transformer function to apply to each element
     * @return sentinel with type R
     */
    @Override
    public <R> InfiniteList<R> map(Transformer<? super Object, ? extends R> mapper) {
      @SuppressWarnings("unchecked")
      InfiniteList<R> output = (InfiniteList<R>) SENTINEL;
      return output;
    }

    /**
     * Returns an infinite list containing only the elements of this list that
     * satisfy the given predicate (always sentinel in this case).
     * @param predicate a boolean condition that tests each element
     * @return sentinel
     */
    @Override
    public InfiniteList<Object> filter(BooleanCondition<? super Object> predicate) {
      return this;
    }


    /**
     * Returns an infinite list consisting of the first n elements of this list.
     * Always sentinel in this case.
     * @param n the maximum number of elements to return
     * @return sentinel
     */
    @Override
    public InfiniteList<Object> limit(long n) {
      return this;
    }

    /**
     * Throws Exception as there is no head.
     *
     * @return the head of this list
     * @throws NoSuchElementException if this list is empty
     */
    @Override
    public Object head() throws NoSuchElementException {
      throw new NoSuchElementException();
    }

    /**
     * Throws Exception as there is no tail.
     *
     * @return the tail of this list
     * @throws NoSuchElementException if this list is empty
     */
    @Override
    public InfiniteList<Object> tail() throws NoSuchElementException {
      throw new NoSuchElementException();
    }


    /**
     * Returns a new ArrayList containing which is empty.
     *
     * @return a new ArrayList containing which is empty
     */
    @Override
    public List<Object> toList() {
      return new java.util.ArrayList<>();
    }

    /**
     * Returns a Sentinel.
     *
     * @param predicate a BooleanCondition 
     * @return a Sentinel
     */
    @Override
    public InfiniteList<Object> takeWhile(BooleanCondition<? super Object> predicate) {
      return this;
    }

    /**
     * Reduces this InfiniteList using the given identity and accumulator (Returns sentinel).
     * @param <U> The type of the identity and result of the reduction
     * @param identity The initial value of the reduction
     * @param accumulator The accumulator function to apply to each element
     * @return The result of the reduction (a sentinel)
     */
    @Override
    public <U> U reduce(U identity, Combiner<U, ? super Object, U> accumulator) {
      return identity;
    }

    /**
     * Returns the number of elements in the list which is 0.
     * @return 0
     */
    @Override
    public long count() {
      return 0;
    }
  }



  /**
   * Constructor.
   */
  private InfiniteList() { 
    this.head = null; 
    this.tail = null;
  }

  /**
   * Generates an infinite list of elements using a producer.
   * @param <T> The type of elements in the list.
   * @param producer The producer used to generate elements.
   * @return An infinite list of elements generated by the producer.
   */
  public static <T> InfiniteList<T> generate(Producer<T> producer) {
    return new InfiniteList<>(Lazy.of(() -> Maybe.some(producer.produce())), 
        Lazy.of(() -> InfiniteList.generate(producer)));
  }

  /**
   * Generates an infinite list of elements using a transformer.
   * @param <T> The type of elements in the list.
   * @param seed The initial element in the list.
   * @param next The transformer used to generate subsequent elements.
   * @return An infinite list of elements generated by the transformer.
   */
  public static <T> InfiniteList<T> iterate(T seed, Transformer<T, T> next) {
    return new InfiniteList<>(seed, 
        () -> InfiniteList.iterate(next.transform(seed), next));
  }


  /**
   * Constructs an infinite list with a head element and a tail producer.
   * @param head The head element of the list.
   * @param tail The producer used to generate the tail of the list.
   */
  private InfiniteList(T head, Producer<InfiniteList<T>> tail) {
    this.head = Lazy.of(() -> Maybe.some(head));
    this.tail = Lazy.of(tail);
  }

  /**
   * Constructs an infinite list with a head element and a tail infinite list.
   * @param head The head element of the list.
   * @param tail The infinite list which serves as the tail of the list.
   */
  private InfiniteList(Lazy<Maybe<T>> head, Lazy<InfiniteList<T>> tail) {
    this.head = head;
    this.tail = tail;
  }

  /**
   * Returns the head element of this list.
   * @return The head element of this list.
   */
  public T head() {
    return this.head.get().orElseGet(() -> this.tail.get().head());
  }

  /**
   * Returns the tail of this infinite list.
   * @return The tail of this infinite list.
   */
  public InfiniteList<T> tail() {
    InfiniteList<T> t = this;
    while (t.head.get() == Maybe.none()) {
      t = t.tail.get();
    }
    return t.tail.get();
  }

  /**
   * Applies the given transformer to each element of this list and returns
   * an infinite list of the results.
   *
   * @param <R> the type of the elements in the output list
   * @param mapper a transformer function to apply to each element
   * @return an infinite list of the results
   */
  public <R> InfiniteList<R> map(Transformer<? super T, ? extends R> mapper) {
    return new InfiniteList<>(Lazy.of(() -> this.head.get().map(mapper)), 
        Lazy.of(() -> this.tail.get().map(mapper)));
  }


  /**
   * Returns an infinite list containing only the elements of this list that
   * satisfy the given predicate.
   *
   * @param predicate a boolean condition that tests each element
   * @return an infinite list containing only the elements that satisfy the predicate
   */
  public InfiniteList<T> filter(BooleanCondition<? super T> predicate) {
    return new InfiniteList<>(Lazy.of(() -> this.head.get().filter(predicate)),
        Lazy.of(() -> this.tail.get().filter(predicate)));
  }

  /**
   * Returns an infinite list which is a sentinel.
   * @param <T> type of element
   * @return An infinite list which is a sentinel.
   */
  public static <T> InfiniteList<T> sentinel() {
    @SuppressWarnings("unchecked")
    InfiniteList<T> output = (InfiniteList<T>) SENTINEL;
    return output;
  }

  /**
   * Returns an infinite list consisting of the first n elements of this list.
   *
   * @param n the maximum number of elements to return
   * @return an infinite list consisting of the first n elements of this list
   */
  public InfiniteList<T> limit(long n) {
    if (n <= 0) {
      @SuppressWarnings("unchecked")
      InfiniteList<T> output = (InfiniteList<T>) SENTINEL;
      return output;
    } else {
      return new InfiniteList<>(this.head,
          Lazy.of(() -> this.head.get().map(x -> this.tail.get().limit(n - 1))
            .orElseGet(() -> this.tail.get().limit(n))));
    }
  }


  /**
   * Returns a new infinite list that contains all elements of this list up to but not 
   * including the first element that does not satisfy the given predicate.
   * @param predicate A condition that tests each element in the list.
   * @return A new infinite list after applying predicate 
   */
  public InfiniteList<T> takeWhile(BooleanCondition<? super T> predicate) {
    Lazy<Maybe<T>> newHead = Lazy.of(() -> this.head.get().filter(predicate));
    return new InfiniteList<>(newHead,
        Lazy.of(() -> this.head.get()
          .map(x -> newHead.get()
            .map(y -> this.tail.get().takeWhile(predicate))
            .orElseGet(() -> sentinel()))
          .orElseGet(() -> this.tail.get().takeWhile(predicate))));
  }

  /**
   * Returns false.
   * @return false.
   */
  public boolean isSentinel() {
    return false;
  }

  /**
   * Reduces this InfiniteList using the given identity and accumulator.
   * @param <U> The type of the identity and result of the reduction
   * @param identity The initial value of the reduction
   * @param accumulator The accumulator function to apply to each element
   * @return The result of the reduction 
   */
  public <U> U reduce(U identity, Combiner<U, ? super T, U> accumulator) {
    U extra = identity;
    InfiniteList<T> t = this;
    while (!t.isSentinel()) {
      U temp = extra;
      extra = t.head.get().map(x -> accumulator.combine(temp, x)).orElseGet(() -> temp);
      t = t.tail.get();
    }
    return extra;
  }

  /**
   * Returns the number of elements in this InfiniteList.
   * @return The number of elements in this InfiniteList 
   */
  public long count() {
    return this.reduce(0L, (x, y) -> x + 1);
  }

  /**
   * Returns a list containing all elements of this InfiniteList.
   * @return A list containing all elements of this InfiniteList 
   */
  public List<T> toList() {
    List<T> list = new java.util.ArrayList<>();
    InfiniteList<T> t = this;
    while (!t.isSentinel()) {
      t.head.get().ifPresent(x -> list.add(x));
      t = t.tail.get();
    }
    return list;
  }

  /**
   * Returns a string representation of this InfiniteList.
   * @return A string representation of this InfiniteList 
   */ 
  public String toString() {
    return "[" + this.head + " " + this.tail + "]";
  }
}

